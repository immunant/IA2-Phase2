#pragma once
#include "pkey_init.h"
#include <stdio.h>

// On linux protection key 0 is the default for anything not covered by
// pkey_mprotect so untrusted compartments have the lower 2 bits of PKRU cleared
#define PKRU_UNTRUSTED "0xFFFFFFFC"
#define NUM_PKEYS 15

// Parameter passed to __libia2_gate_push invocation if callee is an untrusted
// library. This is added to wrappers generated by the rewriter by default if
// `--compartment-key` is not specified.
#define NO_PKEY -1

// Attribute for variables that can be accessed from any untrusted compartments.
#define IA2_SHARED_DATA __attribute__((section("ia2_shared_data")))

#ifdef IA2_WRAPPER
#define IA2_WRAP_FUNCTION(name)
#else
#define IA2_WRAP_FUNCTION(name) __asm__(".symver " #name ",__ia2_" #name "@IA2")
#endif

#ifdef LIBIA2_INSECURE

#define GATE_PUSH
#define GATE_POP

#else

// Set PKRU to untrusted using eax, r10 and r11 as scratch registers.
#define UNTRUSTED_GATE                                                         \
  "mov r10d, ecx\n"                                                            \
  "mov r11d, edx\n"                                                            \
  "mov eax, " PKRU_UNTRUSTED                                                   \
  "\n"                                                                         \
  "mov ecx, 0\n"                                                               \
  "mov edx, 0\n"                                                               \
  "wrpkru\n"                                                                   \
  "mov edx, r11d\n"                                                            \
  "mov ecx, r10d\n"

// FIXME:
#define PKEY_UNINITIALIZED "0xfffffffe"
#define TRUSTED_GATE(...) _TRUSTED_GATE(__VA_ARGS__)

// TODO: Add static assert on pkey index if possible
// Set PKRU based on pkey_idx using eax, r10 and r11 as scratch registers.
#define _TRUSTED_GATE(pkey_idx)                                                \
  "mov r10d, ecx\n"                                                            \
  "mov r11d, edx\n"                                                            \
  "mov rax, QWORD PTR IA2_INIT_DATA@GOTPCREL[rip]\n"                           \
  "mov ecx, " #pkey_idx                                                        \
  "\n"                                                                         \
  "mov eax, DWORD PTR [rax + rcx * 4]\n"                                       \
  "cmp eax, " PKEY_UNINITIALIZED                                               \
  "\n"                                                                         \
  "jne 0f\n"                                                                   \
  "call exit@plt\n"                                                            \
  "0:\n" /* Calculate the new PKRU from the key index */ /* new_pkru = ~((3 << \
                                                            (2 * pkey_idx)) |  \
                                                            3); */             \
  "add eax, eax\n"                                                             \
  "mov edx, 3\n"                                                               \
  "mov ecx, eax\n"                                                             \
  "shl edx, cl\n"                                                              \
  "mov eax, edx\n"                                                             \
  "add eax, 3\n"                                                               \
  "not eax\n"                                                                  \
  "mov ecx, 0\n"                                                               \
  "mov edx, 0\n"                                                               \
  "wrpkru\n"                                                                   \
  "mov edx, r11d\n"                                                            \
  "mov ecx, r10d\n"

#if CALLEE_PKEY >= NUM_PKEYS
#error Invalid CALLEE_PKEY
#elif CALLEE_PKEY == NO_PKEY
#define GATE_PUSH UNTRUSTED_GATE
#elif defined(CALLEE_PKEY)
#define GATE_PUSH TRUSTED_GATE(CALLEE_PKEY)
#endif

#if CALLER_PKEY >= NUM_PKEYS
#error Invalid CALLER_PKEY
#elif CALLER_PKEY == NO_PKEY
#define GATE_POP UNTRUSTED_GATE
#elif defined(CALLER_PKEY)
#define GATE_POP TRUSTED_GATE(CALLER_PKEY)
#endif

#endif

// TODO: Remove this after adding the integrated gates to indirect wrappers
#define __libia2_gate_push(x)
#define __libia2_gate_pop()

#define IA2_FNPTR_WRAPPER_VOID(target, ty)                                     \
  ({                                                                           \
    IA2_FNPTR_WRAPPER_##ty(IA2_fnptr_wrapper_##target) {                       \
      __libia2_gate_push(NO_PKEY);                                             \
      target(IA2_FNPTR_ARG_NAMES_##ty);                                        \
      __libia2_gate_pop();                                                     \
    }                                                                          \
    (struct IA2_fnptr_##ty){(char *)IA2_fnptr_wrapper_##target};               \
  })

#define IA2_FNPTR_UNWRAPPER(target, ty)                                        \
  ({                                                                           \
    IA2_FNPTR_WRAPPER_##ty(IA2_fnptr_wrapper_##target) {                       \
      __libia2_gate_push(NO_PKEY);                                             \
      IA2_FNPTR_RETURN_##ty(__res) =                                           \
          ((IA2_FNPTR_TYPE_##ty)(target.ptr))(IA2_FNPTR_ARG_NAMES_##ty);       \
      __libia2_gate_pop();                                                     \
      return __res;                                                            \
    }                                                                          \
    IA2_fnptr_wrapper_##target;                                                \
  })

#define IA2_FNPTR_UNWRAPPER_VOID(target, ty)                                   \
  ({                                                                           \
    IA2_FNPTR_WRAPPER_##ty(IA2_fnptr_wrapper_##target) {                       \
      __libia2_gate_push(NO_PKEY);                                             \
      ((IA2_FNPTR_TYPE_##ty)(target.ptr))(IA2_FNPTR_ARG_NAMES_##ty);           \
      __libia2_gate_pop();                                                     \
    }                                                                          \
    IA2_fnptr_wrapper_##target;                                                \
  })

// We must declare the sections used to pad the end of each program header
// segment to make sure their rwx permissions match the segment they're placed
// in. Otherwise if the padding sections are declared in the linker script
// without any input sections they and their corresponding segment will default
// to rwx. We avoid using .balign to align the sections at the start of each
// segment because it inserts a fill value (defaults to 0) which may break some
// sections (e.g.  insert null pointers into .init_array).
#define NEW_SECTION(name)                                                      \
  __asm__(".section " #name                                                    \
          "\n\
             .previous");

// Initializes a compartment with the nth key in IA2_INIT_DATA when the ELF
// invoking this is loaded. This must only be called once for each key. The
// compartment includes all segments in the ELF except the `ia2_shared_data`
// section, if one exists.
#define INIT_COMPARTMENT(n)                                                    \
  NEW_SECTION(".fini_padding");                                                \
  NEW_SECTION(".rela.plt_padding");                                            \
  NEW_SECTION(".eh_frame_padding");                                            \
  NEW_SECTION(".bss_padding");                                                 \
  __attribute__((constructor)) static void init_pkey_ctor() {                  \
    initialize_compartment(n, &init_pkey_ctor);                                \
  }
