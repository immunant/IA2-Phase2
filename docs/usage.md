# Compartmentalization Guide

To compartmentalize a program, cross-compartment calls must go through call gate
wrappers which change PKRU, switch stacks and scrub unused registers.
Compartments are the dynamic shared objects (DSOs) a program is comprised of and
they are either assigned one of 15 protection keys or default to the untrusted
protection key. This doc walks through how to compartmentalize a program.

## Direct calls

Cross-compartment direct calls go through call gate wrappers defined in shims
generated by the header-rewriter. Running the rewriter on a compartment's
exported headers produces a source file for a shim specific to the compartment.
The shim library must be specific to both the compartment and the caller so
`CALLER_PKEY` must be set to `0-15` with the `-D` flag when compiling the shim.
Note that `-DCALLER_PKEY=0` assigns the untrusted protection key to the caller's
compartment. The rewriter also produces a file with linker flags which must be
used with `-Wl,@$ARGS_FILE` when linking the caller's shared objects.

Consider a main binary which exports `foo.h` and a library which exports `bar.h`
and `baz.h` with direct calls in both directions. To wrap calls in both
directions we invoke the rewriter twice to generate two shim libraries as shown
below. Then the original shared objects must be rebuilt with the linker flags
generated by the rewriter.

```
                     +----------------+
                     | library shim   |
             /------>| libbar_shim.so |------\
calls to bar |       | __wrap_bar() { |      | __wrap_bar calls the
become calls |       |   bar();       |      | original bar
to __wrap_bar|       | }              |      |
             |       +----------------+      V
+---------------+                        +----------------+
|               |                        |                |
|               |                        | shared library |
| main binary   |                        | libbar.so      |
| foo() { ... } |                        | bar() { ... }  |
|               |                        |                |
+---------------+                        +----------------+
            ^       +----------------+      | calls to foo
__wrap_foo  |       | main           |      | become calls
calls the   |       | binary shim    |      | to __wrap_foo
original foo\-------| libmain_shim.so|<-----/
                    | __wrap_foo() { |
                    |   foo();       |
                    | }              |
                    +----------------+
```

Let's assign the main binary protection key 1 and give the library the default,
untrusted protection key. We must specify each compartment's protection key by
passing `--compartment-pkey=$N` to the rewriter when generating their
corresponding shim sources. Then we generate the shim sources and linker args
files with the following. This also modifies `foo.h`, `bar.h` and `baz.h`
in-place and creates backups of the original headers.

```
# Generate main_shim.c and main_shim.c.args and specify the main compartment's
# pkey.
header-rewriter --compartment-pkey=1 main_shim.c foo.h -- -I $SYS_HEADERS

# May omit --compartment-pkey or use --compartment-pkey=0 since the library has
# the default pkey.
header-rewriter libbar_shim.c bar.h baz.h -- -I $SYS_HEADERS
```

To compile the shim sources we specify the shim caller's pkey. We also always disable
lazy binding.

```
# CALLER_PKEY for the main shim is 0 since the library has the untrusted pkey
gcc -shared main_shim.c -Wl,-z,now -DCALLER_PKEY=0 -I $IA2_INCLUDE_DIR \
    -o libmain_shim.so

# CALLER_PKEY for the library shim is the main binary's pkey
gcc -shared libbar_shim.c -Wl,-z,now -Wl,--version-script,libbar_shim.c.syms \
    -DCALLER_PKEY=1 -I $IA2_INCLUDE_DIR -o libbar_shim.so
```

We now modify the main binary's source to initialize our runtime using
`INIT_RUNTIME` and assign it a protection key with `INIT_COMPARTMENT`.
`INIT_RUNTIME` must be invoked once in the main binary. To assign a protection
key to another shared object, only `INIT_COMPARTMENT` must be added to one of
the object's source files.

```
// main.c
// This header defines INIT_RUNTIME and INIT_COMPARTMENT
#include <ia2.h>

// Initialize the runtime and allocate 1 protection key.
INIT_RUNTIME(1);

// Assign protection key 1 to the main binary.
INIT_COMPARTMENT(1);
```

Then we rebuild the library and ensure it's linked against the main shim. We
must also include the modified header(s) corresponding to the main shim source.
In this case that means including the modified `foo.h`, but the original
`bar.h` and `baz.h`.

```
gcc -shared bar.c libmain_shim.so -Wl,-z,now -I $IA2_INCLUDE_DIR -fPIC \
    -o libbar.so
```

Finally we rebuild the main binary. This time we include the modified `bar.h`
and `baz.h` since they correspond to the library shim and the original `foo.h`.

```
gcc main.c libbar.so libbar_shim.so libmain_shim.so -Wl,-z,now \
    -I $IA2_INCLUDE_DIR -fPIC -Wl,-rpath=. -Wl,-T/$REPO_ROOT/libia2/padding.ld
```

Shared objects that are assigned one a trusted protection key must have certain
sections page-aligned and padded. This includes `ia2_shared_data`,
`ia2_shared_rodata`, `.dynamic` and other sections that must be accessible from
to any compartment. The `padding.ld` linker script ensures this. This linker
script may augment other linker scripts, but it is the user's responsibility to
ensure these shared sections are page-aligned and padded. Failure to do this
causes the runtime to terminate the program during initialization.

If direct calls occur in only one direction (e.g. libraries rarely call the main
binary directly), only one shim is required. To wrap calls between two shared
libraries in different compartments, the process is the same.

## Indirect calls

Cross-compartment indirect calls go through call gate wrappers defined by macros
which must be manually added to the program source. We assume a compartment's
exported headers define all function pointer types which it may receive from or
send to another compartment. With this assumption the rewriter has an
`--output-header` option which generates a header with the indirect wrapper
macros. The rewritten exported headers will include the output header by its
full path, so using the indirect wrappers should not require adding any new
includes.

Let's again consider a main binary with pkey 1 and a library with the untrusted
pkey. This time the library exports `ptr.h` with the following

```
typedef int(*Fn)(int);
void set_fn_ptr(Fn f);
Fn get_fn_ptr(void);
```

Running the rewriter on `ptr.h` will change `Fn` from a typedef for a function
pointer to a typedef for an opaque struct. The output header will then have the
macros needed to manually wrap function pointers in the main binary's source.
Function pointers that will be sent to another compartment or are visible to the
library (e.g. global variable) must be wrapped as follows. Failure to manually
wrap all cross-compartment function pointers or using the incorrect mangled type
name, will give a warning when compiling the main binary. This should be
converted to a hard-error with `-Werror=incompatible-pointer-types`.

```
// main.c
// ptr.h includes ia2.h which defines the IA2_* macros and the output header
// which defines the mangled type macros (i.e. _ZTSPFiiE).
#include "ptr.h"

// This creates an opaque struct set to NULL.
Fn uninit = IA2_NULL_FNPTR(_ZTSPFiiE);

int incr(int x) { return x + 1; }

int main() {
    // With the modified ptr.h this will fail to compile.
    // set_fn_ptr(incr);

    // This defines a wrapper to call `incr` with pkey 1.
    IA2_DEFINE_WRAPPER(incr, _ZTSPFiiE, 1);

    // If this wrapper was already defined in another source file, you must
    // declare it as follows to avoid multiple definition linker errors
    // IA2_DECLARE_WRAPPER(incr, _ZTSPFiiE, 1);

    // This passes the wrapper defined on the previous line as an argument to
    // set_fn_ptr
    set_fn_ptr(IA2_WRAPPER(incr, 1));

    // Alternatively in a function's scope, IA2_DEFINE_WRAPPER_FN_SCOPE may be
    // used as follows to define a wrapper in a statement expression that
    // expands to a pointer to the wrapper. This and the other IA2_*_FN_SCOPE
    // macros may be used to minimize the number of changes/mangled type names
    // needed.
    // set_fn_ptr(IA2_DEFINE_WRAPPER_FN_SCOPE(incr, _ZTSPFiiE, 1));
}
```

To call a function pointer received from another compartment use
`IA2_CALL` to create a function pointer from an opaque struct.

```
// main.c
#include "ptr.h"

int main() {
    Fn decr = get_fn_ptr();
    // This will fail to compile with modified ptr.h
    // decr();

    // The NULL check must be done with IA2_FNPTR_UNWRAPPER because it always
    // returns a non-null pointer.
    if (!IA2_FNPTR_IS_NULL(decr)) {
        // This turns the opaque struct into a function pointer that
        // adds call gates to `decr`. This function pointer must be called
        // immediately.
        IA2_CALL(decr, _ZTSPFiiE, 0, UNTRUSTED)();
    }
}
```

## Shared headers

The examples above assume that each compartment exports a unique set of headers
which define its interface. However it's not always possible to assign each
header to one compartment. For example, a header may contain declarations for
functions defined in one compartment and types used by multiple compartments.
Assuming all functions declared in a header belong to a single compartment, the
rewriter handles this with the `shared-headers` option.


Using the example shown above let's say that `ptr.h` is the same, but
`set_fn_ptr` and `get_fn_ptr` are defined in the main binary. The library uses
the `Fn` typedef so it's headers include `ptr.h`. When we run the rewriter we
must pass in `ptr.h`, but also blacklist the function declarations from being
rewritten.

```
header-rewriter lib_shim.c lib.h ptr.h --shared-headers ptr.h
```

This will again modify `lib.h` and `ptr.h` in-place, but avoids changing the
function declarations in `ptr.h` since the library does not define those
functions. Then by including the modified `ptr.h` in the main binary source, we
can wrap function pointers with `IA2_FNPTR_WRAPPER(foo, _ZTSPFiiE, ...)`.

TODO: Add blurbs on public vs private headers and `$SYS_HEADERS`
