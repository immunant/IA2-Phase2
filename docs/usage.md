# Compartmentalization Guide

To compartmentalize a program, cross-compartment calls must go through call gate
wrappers which change PKRU, switch stacks and scrub unused registers.
Compartments are the dynamic shared objects (DSOs) a program is comprised of and
they are either assigned one of 15 protection keys or default to the untrusted
protection key. This doc walks through how to compartmentalize a program and
notes incompatible features.

## Direct calls

Cross-compartment direct calls go through call gate wrappers defined in shims
generated by the header-rewriter. Running the rewriter on a compartment's
exported headers produces a source file for a shim specific to the compartment.
The shim library must be specific to both the compartment and the caller so
`CALLER_PKEY` must be set to `0-15` or `UNTRUSTED` with the `-D` flag when
compiling the shim. The rewriter also produces a version script which must be
passed to the linker with `-Wl,--version-script,$SCRIPT` when compiling the
shim.

Consider a main binary which exports `foo.h` and a library which exports `bar.h`
and `baz.h` with direct calls in both directions. To wrap calls in both
directions we invoke the rewriter twice to generate two shim libraries as shown
below. Then the original shared objects must be rebuilt from source.

```
                    +----------------+
                    | library shim   |
            /------>| libbar_shim.so |------\
calls to bar|       | ia2_bar() {    |      | ia2_bar calls the
become calls|       |   bar();       |      | original bar
to ia2_bar  |       | }              |      |    
            |       +----------------+      V
+---------------+                        +----------------+
|               |                        |                |
|               |                        | shared library |
| main binary   |                        | libbar.so      |
| foo() { ... } |                        | bar() { ... }  |
|               |                        |                |
+---------------+                        +----------------+
            ^       +----------------+      | calls to foo
ia2_foo     |       | main           |      | become calls
calls the   |       | binary shim    |      | to ia2_foo
original foo\-------| libmain_shim.so|<-----/
                    | ia2_foo() {    |
                    |   foo();       |
                    | }              |
                    +----------------+
```

Let's assign the main binary protection key 0 and let the library use the
default. Then we generate the shim sources and version scripts with the
following. This also modifies `foo.h`, `bar.h` and `baz.h` in-place and creates
backups of the original headers.

```
# Generate main_shim.c and main_shim.c.syms
header-rewriter --compartment-pkey=0 main_shim.c foo.h -- -I $SYS_HEADERS

# Omit --compartment-pkey since the library uses the default
header-rewriter libbar_shim.c bar.h baz.h -- -I $SYS_HEADERS
```

To compile the shim sources we specify the shim's caller and version script. We
also always disable lazy binding.

```
# CALLER_PKEY for the main shim is "UNTRUSTED" since the library has no pkey
gcc -shared main_shim.c -Wl,-z,now -Wl,--version-script,main_shim.c.syms \
    -DCALLER_PKEY=UNTRUSTED -I $IA2_INCLUDE_DIR -o libmain_shim.so

# CALLER_PKEY for the library shim is the main binary's pkey
gcc -shared libbar_shim.c -Wl,-z,now -Wl,--version-script,libbar_shim.c.syms \
    -DCALLER_PKEY=0 -I $IA2_INCLUDE_DIR -o libbar_shim.so
```

We now modify the main binary's source to initialize our runtime using
`INIT_RUNTIME` and assign it a protection key with `INIT_COMPARTMENT`.
`INIT_RUNTIME` must be invoked once in the main binary. To assign a protection
key to another shared object, only `INIT_COMPARTMENT` must be added to one of
the object's source files.

```
// main.c
// This header defines INIT_RUNTIME and INIT_COMPARTMENT
#include <ia2.h>

// Initialize the runtime and allocate 1 protection key.
INIT_RUNTIME(1);

// Assign protection key 0 to this shared object.
INIT_COMPARTMENT(0);
```

Then we rebuild the library and ensure it's linked against the main shim. We
must also include the modified header(s) corresponding to the main shim source.
In this case that means including the modified `foo.h`, but the original
`bar.h` and `baz.h`.

```
gcc -shared bar.c libmain_shim.so -Wl,-z,now -I $IA2_INCLUDE_DIR -fPIC \
    -o libbar.so
```

Finally we rebuild the main binary. This time we include the modified `bar.h`
and `baz.h` since they correspond to the library shim and the original `foo.h`.

```
gcc main.c libbar.so libbar_shim.so libmain_shim.so libia2.so -Wl,-z,now \
    -I $IA2_INCLUDE_DIR -fPIC -Wl,-rpath=. -Wl,-T/$REPO_ROOT/libia2/padding.ld
```

libia2.so is located under `/$REPO_ROOT/libia2/target/release/` after building
the crate with `cargo build --release`.

Shared objects that are assigned a protection key must have their
`ia2_shared_data` and `ia2_shared_rodata` sections page-aligned and padded, if
they exist. The `padding.ld` script is used to ensure this. These linker scripts
may augment other linker scripts, but it is the user's responsibility to ensure
these sections are page-aligned and padded. Failure to do this causes the
runtime to terminate the program during initialization.

If direct calls occur in only one direction (e.g. libraries rarely call the main
binary directly), only one shim is required. To wrap calls between shared
libraries in different compartments, the process is the same, except for the
different linker scripts noted above.

### Prebuilt libraries

Libraries which are assigned a protection key must currently be built from
source. If a library is not assigned a protection key, a prebuilt may be used if
it does not directly call another compartment. Although a prebuilt can be linked
against another compartment's shim, this will not work as intended because
cross-compartment direct calls in the prebuilt will call the original function.

## Indirect calls

Cross-compartment indirect calls go through call gate wrappers in macros which
must be manually added to the program source. We assume a compartment's exported
headers define the function pointer types which it may receive from or send to
another compartment. With this assumption the rewriter has an `--output-header`
option which generates a header with the indirect wrappers. The modified
exported headers will include the output header by its full path, so using the
indirect wrappers does not require adding any new includes.

Let's again consider a main binary with pkey 0 and a library with the default
pkey. This time the library exports `ptr.h` with the following

```
typedef int(*Fn)(int);
void set_fn_ptr(Fn f);
Fn get_fn_ptr(void);
```

Running the rewriter on `ptr.h` will change `Fn` from a typedef for a function
pointer to a typedef for an opaque struct. The output header will then have the
macros needed to manually wrap function pointers in the main binary's source.
Function pointers that will be sent to another compartment or are visible to the
library (e.g. global variable) must be wrapped as follows. Failure to manually
wrap all cross-compartment function pointers or using the incorrect mangled type
name, will give a warning when compiling the main binary. This should be
converted to a hard-error with `-Werror=incompatible-pointer-types`.

```
// main.c
// This header defines IA2_FNPTR_WRAPPER
#include <ia2.h>
// This is the modified version of ptr.h which defines _ZTSPFiiE
#include "ptr.h"

// This creates an opaque struct set to NULL.
Fn uninit = IA2_NULL_FNPTR(_ZTSPFiiE);

int incr(int x) { return x + 1; }

int main() {
    // With the modified ptr.h this will fail to compile.
    // set_fn_ptr(incr);

    // This wraps `incr` before sending it to the library. The wrappers expects
    // an untrusted caller (default pkey) and will call `incr` with pkey 0.
    set_fn_ptr(IA2_FNPTR_WRAPPER(incr, _ZTSPFiiE, UNTRUSTED, 0));
}
```

To call a function pointer received from another compartment use
`IA2_FNPTR_UNWRAPPER` to create a function pointer from an opaque struct.

```
// main.c
#include <ia2.h>
#include "ptr.h"

int main() {
    Fn decr = get_fn_ptr();
    // This will fail to compile with modified ptr.h
    // decr();

    // The NULL check must be done without IA2_FNPTR_UNWRAPPER because it always
    // returns a non-null pointer.
    if (!IA2_FNPTR_IS_NULL(decr)) {
        // This "unwraps" the opaque struct producing a function pointer that
        // adds call gates to `decr` and immediately calls it.
        IA2_FNPTR_UNWRAPPER(decr, _ZTSPFiiE, 0, UNTRUSTED)();
    }
}
```

### Prebuilt libraries

Since the main binary is the only compartment with a pkey in this example, only
that side requires manual changes. This means a prebuilt library may be used in
this case. In general if a shared object cannot trust another compartment to
wrap cross-compartment function pointers, the object's source must be modified.

## Shared headers

The examples above assume that each compartment exports a unique set of headers
which define its interface. However it's not always possible to assign each
header to one compartment. For example, a header may contain declarations for
functions defined in one compartment and types used by multiple compartments.
Assuming all functions declared in a header belong to a single compartment, the
rewriter handles this with the `shared-headers` option.


Using the example shown above let's say that `ptr.h` is the same, but
`set_fn_ptr` and `get_fn_ptr` are defined in the main binary. The library uses
the `Fn` typedef so it's headers include `ptr.h`. When we run the rewriter we
must pass in `ptr.h`, but also blacklist the function declarations from being
rewritten.

```
header-rewriter lib_shim.c lib.h ptr.h --shared-headers ptr.h
```

This will again modify `lib.h` and `ptr.h` in-place, but avoids changing the
function declarations in `ptr.h` since the library does not define those
functions. Then by including the modified `ptr.h` in the main binary source, we
can wrap function pointers with `IA2_FNPTR_WRAPPER(foo, _ZTSPFiiE, ...)`.

TODO: Add blurbs on public vs private headers and `$SYS_HEADERS`
